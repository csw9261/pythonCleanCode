Chapter2. 파이썬스러운 코드 
	* 인덱스와 슬라이스 
		- 파이썬은 음수 인덱스를 사용하여 끝에서부터 접근이 가능하다 
		- 슬라이스를 사용하여 특정 구간의 요소를 구할 수 있다.
		
		1).  자체 시퀀스 생성 
			- __getitem__을 사용해 내장 메서드를 사용하지 않고 특정 동작을 커스터마이징 할 수 있다.
	
	* 컨텍스트 관리자(context manager)
		- 컨텍스트 관리자(Context Manager)는 리소스의 획득 및 해제를 자동으로 처리할 수 있게 해주는 기능
		- with 문을 사용해 컨텍스트 관리자로 진입하게 할 수 있다.
		- context 관리자는 __enter__와 __exit__ 두 개의 매직 메서드로 구성
	 		with 는 __enter__을 호출한다.
	 	- context 관리자 블록 내에 예외 또는 오류가 있는 경우도 __exit__ 메서드가 호출되어 정리조건을 안전하게 실행
	 	- 컨텍스트 관리자는 블록 전후에 필요로 하는 특정 로직을 제공하기 위해 자체 컨텍스트 관리자를 구현할 수도 있음
	 	- 컨텍스트 관리자는 관심사를 분리하고 독립적으로 유지되어야 하는 코드를 쉽게 관리하기 위한 방법
		- __enter__에서 무언가를 반환하게 하는건 좋은 습관이다. 
		
		1). 컨텍스트 관리자 구현
			- 함수에 contextlib.contextmanager 데코레이터를 적용하면 해당 함수의 코드를 컨텍스트 관리자로 변환한다.
			- ContextDecorator를 상속하여 매직메서드에 필요한 로직을 구현할 수도 있다.
			
	* 컴프리헨션(Comprehension)과 할당 표현식 
			- 단일 명령어로 데이터 구조를 생성하려면 컴프리헨션을 사용하는 것이 좋다.
			- 반복문에 컴프리헨션ㅇ르 사용하면 반복적 호출 대신 단일 파이썬 명령어를 호출해 일반적으로 더 나은 성능을 보여준다
				ex) numbers = [run_cal(i) for i in range(10)]
			- 더 간결한 코드가 항상 더 나은 코드를 의미하는 것은 아니다. 가독성을 생각해야 한다.

	* 프로퍼티, 속성(Attribute)과 객체 메서드의 다른 타입들
		1). 파이썬에서의 밑줄
			- 파이썬의 모든 객체는 기본적으로 public 속성을 가지고 있다.
			- 파이썬 네이밍 규칙중에 _로 시작하는 변수는 private 속성을 의미한다.(외부에서 호출하지 않기를 기대한다는 의미)
			- 밑줄로 시작하는 속성에서 예외적으로 단위 테스트에서 직접 내부 속성에 접근하는 경우라면 접근이 허용 될 수도 있다.
			- 이중밑줄(__)을 사용하는 경우에 파이썬은 다른 이름을 만든다-> 이름 맹글링(name mangling)
				이름 맹글링은 이중 밑줄을 사용한 변수의 이름을 "_<class_name>__<attribute-name>" 형태로 변경한다.
				여러번 확장되는 클래스의 메서드 이름을 충돌없이 오버라이드 하기 위한 것이다.
				ex) self.__timeout = 1 으로 설정하면 접근은 _Connector__timeout으로 해야한다 
					-> con._Connector__timeout
		
		2). 프로퍼티
			- 파이썬에서는 프로퍼티를 사용하여 setter와 getter 메서드를 간결하게 캡슐화 할 수 있다.
			- 프로퍼티를 사용하면 메서드 이름에 따라 실제 동작이 어떻게 하는지 혼란스러운 경우를 피할 수 있다.
		
		3). 보다 간결한 구문으로 클래스 만들기
			- dataclasses 모듈을 사용하면 모든 클래스의 속성에 대해서 __init__ 메서드로 정의한 것처럼 인스턴스 속성으로 처리한다.
			- dataclasses 모듈은 field라는 객체를 제공하는데 이 객체는 해당 속성에 특별한 특징이 있음을 표시한다.
			- 프로퍼티는 명령-쿼리 분리원칙을 따르기 위한 방법 (CC08)
			- dataclasses 모듈을 사용하면서 __post_init__을 사용하면 초기화 직후 처리가 가능하다.
		
		4). 이터러블 객체
			- 이터러블은 __iter__ 매직메서드를 구현한 객체, 이터레이터는 __next__ 매직 메서드를 구현 한 객체
			- __iter__에서 이터레이터 객체를 사용하는 것을(for 루프가 __iter__을 호출하고 __iter__는 다시 제너레이터를 생성) 컨테이너 이터러블(container iterable) 이라고 한다. 
		
		5). 컨테이너 객체
			- __contains__ 메서드를 구현한 객체로 in 키워드가 발견될 때 호출한다.
			- 해당 메서드로 코드의 가독성을 매우 크게 높일 수 있다.
		
		6). 객체의 동적인 속성
			- __getattr__ 매직 메서드를 사용하면 객체에 존재하지 않는 속성에 접근할 때 자동으로 호출되고 이를 통해 속성이 없을 때의 기본 동작을 정의할 수 있다.
			- __getattr__을 사용하면서 __dict__ 변수를 사용한다면 객체의 인스턴스에 새로운 속성을 동적으로 추가 할수도 있다.
			- 보일러플레이트가 많거나 중복 코드가 많이 발생하는 경우 __getattr__ 매직메서드가 좋은 선택이 될 수 있다.
			- __getattr__을 남용시 가독성이 떨어짐으로 항상 코드의 간결성과 유지 관리 비용의 트레이드오프(tradeoff)를 고려해야 한다.
		
		7). 호출형 객체(callable)
			- 어떤 기능을 호출 할때마다 관리해야 하는 상태가 있다면 callable 객체를 사용하는 것이 훨씬 편리하다
			- 일반 객체를 사용하는 가장 큰 장점은 객체에 상태를 저장해 호출이 일어날때 정보를 저장하고 나중에 활용한다는 점이다.
		
		8). 매직 메서드 요약
			- __getitem__(key)
				-> 첨자형 객체
				-> 인덱스 접근시 사용
				ex) obj[key], obj[i:k]
			
			- __enter__ , __exit__ 
				-> 컨텍스트 관리자
				-> __enter__: with 진입 시 호출
				-> __exit__: with 문을 벗어날 때 호출
			
			- __iter__, __next__
				-> 이터러블 객체
				-> 이터레이터 동작 원리
					__iter__ 메서드가 호출되면 이터레이터 객체가 반환
					for 루프가 이터레이터의 __next__ 메서드를 호출하여 값을 순차적으로 가져옴
					더 이상 값이 없으면 StopIteration 예외가 발생하여 루프가 종료
				
			- __len__, __getitem__ 
				-> 시퀀스
				-> __len__: 컨테이너의 길이 반환
				-> __getitem__: 인덱스로 접근할 수 있게 함 
				
			- __getattr__ 
				-> 동적 속성 조회
				-> __getattr__ 메서드는 객체에 존재하지 않는 속성에 접근할 때 자동으로 호출된다. 이를 통해 속성이 없을 때의 기본 동작을 정의
			
			- __call__(*args, **kwargs)
				-> 호출형(callable) 객체

	* 파이썬에서 유의할 점
		1). 변경 가능한(mutable) 파라미터의 기본 값
			- 변경 가능한 객체를 함수의 기본인자로 사용하면 안된다.
		
		2). 내장(built-in) 타입 확장 
			- 리스트, 문자열, 사전 같은 내장 탕비을 확장하는 올바른 방법은 collections 모듈을 사용한 것이다.
			





